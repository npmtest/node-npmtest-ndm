{"/home/travis/build/npmtest/node-npmtest-ndm/test.js":"/* istanbul instrument in package npmtest_ndm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ndm/lib.npmtest_ndm.js":"/* istanbul instrument in package npmtest_ndm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ndm = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ndm = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ndm/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ndm && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ndm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ndm\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ndm.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ndm.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ndm.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ndm.__dirname + '/lib.npmtest_ndm.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/index.js":"var _ = require('lodash'),\n  CliSelfInstall = require('./cli-self-install'),\n  ndm = function(packageName, opts) {\n    return CliSelfInstall(_.extend({\n      filter: packageName,\n      appName: packageName\n    }, opts));\n  };\n\n// some other exports are needed.for npme.\nndm.Interview = require('./interview');\n\nmodule.exports = ndm;\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/cli-self-install.js":"// CLI for creating self installing services.\nvar _ = require('lodash'),\n  async = require('async'),\n  cli = null,\n  CliBase = require('./cli-base').CliBase,\n  config = require('./config')(),\n  Service = require('./service'),\n  Installer = require('./installer'),\n  npmconf = require('npmconf'),\n  path = require('path'),\n  S = require('string'),\n  temp = require('temp'),\n  util = require('util'),\n  utils = require('./utils'),\n  yargs = require('yargs');\n\n// handle a user interacting with the\n// command-line, update config appropriately,\n// output human readable messages.\nfunction CliSelfInstall(opts) {\n  _.extend(this, {\n    CliBase: CliBase,\n    logger: require('./logger'),\n    Interview: require('./interview'),\n    service: Service,\n    rimraf: require('rimraf'),\n    argv: yargs.normalize().argv,\n    filter: null, // what service are we self installing?\n  }, opts);\n\n  // for commands like run-script, update service filter.\n  config.filter = this.filter;\n  config.appName = this.appName;\n\n  this.updateConfigWithArgs(this.argv); // update config singleton with args.\n  config.updateWithOSDefaults();\n};\n\nutil.inherits(CliSelfInstall, CliBase);\n\nCliSelfInstall.prototype.listScripts = function(cb) {\n  var _this = this,\n    cb = cb || function() {};\n\n  this._ensureNpmConf(function() {\n    _this['list-scripts'](_this.filter);\n    return cb();\n  });\n};\n\nCliSelfInstall.prototype.runScript = function(cb) {\n  var _this = this,\n    cb = cb || function() {};\n\n  this._ensureNpmConf(function() {\n    _this['run-script'](_this.argv._[1]);\n    return cb();\n  });\n};\n\nCliSelfInstall.prototype.remove = function(cb) {\n  var _this = this,\n    cb = cb || function() {};\n\n  this._ensureNpmConf(function() {\n    _this.CliBase.prototype.remove.call(_this, _this.filter);\n    return cb();\n  });\n};\n\nCliSelfInstall.prototype.install = function(cb) {\n  var _this = this,\n    cb = cb || function() {};\n\n  this._ensureNpmConf(function() {\n    _this.CliBase.prototype.install.call(_this, _this.filter);\n    return cb();\n  });\n};\n\nCliSelfInstall.prototype._runCommand = function(command, serviceName, cb) {\n  var _this = this,\n    cb = cb || function() {};\n\n  this._ensureNpmConf(function() {\n    _this.CliBase.prototype._runCommand.call(_this, command, _this.filter, cb);\n  });\n};\n\nCliSelfInstall.prototype._ensureNpmConf = function(cb) {\n  var _this = this;\n\n  npmconf.load(function (er, conf) {\n    _this.updateConfigWithNpmconf(conf);\n    return cb();\n  });\n};\n\n// export CLI as a singleton, to that\n// it can easily be imported for logging.\nmodule.exports = function(opts) {\n  if (!opts && cli) return cli;\n  else {\n    cli = new CliSelfInstall(opts);\n    return cli;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/cli-base.js":"// base class used by ndm itself, and by the\n// ndm self-install-api.\nvar _ = require('lodash'),\n  async = require('async'),\n  cli = null,\n  config = require('./config')(),\n  Service = require('./service'),\n  Installer = require('./installer'),\n  S = require('string'),\n  temp = require('temp');\n\n// handle a user interacting with the\n// command-line, update config appropriately,\n// output human readable messages.\nfunction CliBase() {}\n\n// updates the configuration singleton\n// with any important npm configuration\nCliBase.prototype.updateConfigWithNpmconf = function(conf) {\n  if (!config.modulePrefix || config.modulePrefix === '') {\n    config.modulePrefix = conf.get('prefix');\n  }\n};\n\n// updates the configuration singleton\n// with any CLI args passed in.\nCliBase.prototype.updateConfigWithArgs = function(argv) {\n  config._argv = argv; // keep track of argv overrides.\n\n  _.keys(config).forEach(function(key) {\n    if (argv[key] && typeof config[key] !== 'function') {\n      config[key] = config.parsers[key] ? config.parsers[key](argv[key]) : argv[key];\n    }\n  });\n};\n\n// generate kwargs CLI parser from config.\nCliBase.prototype.generateArgs = function() {\n  var _this = this,\n    descriptions = config.descriptions(),\n    options = {};\n\n  // populate config flags.\n  _.forIn(config, function(value, key) {\n    if (descriptions[key]) {\n      options[_this._getFlag(key.toLowerCase())] = {\n        alias: S(key).dasherize().s,\n        describe: descriptions[key],\n        default: config[key]\n      };\n    }\n  });\n\n  _this.yargs.options(options);\n\n  // now add the usage info.\n  this.generateUsage();\n};\n\nCliBase.prototype.generateUsage = function() {\n  var _this = this,\n    usage = 'Deploy service daemons directly from npm packages:\\n\\nUsage: $0 <cmd> [options]';\n\n  _.forIn(this.commands, function(value, key) {\n    _this.yargs.command(key, value);\n  });\n\n  this.yargs.example('ndm run-script [<script-name>]', 'run a script using the arguments and environment variables in service.json');\n  this.yargs.example('ndm generate', 'generate os-specific run scripts (upstart, init.d, .plist, etc.)');\n  this.yargs.example('ndm start', 'start all the generated run scripts');\n\n  this.yargs.usage(usage);\n};\n\n// iterate over the key, and find a flag\n// that hasn't yet been used.\nCliBase.prototype._getFlag = function(candidates) {\n  for (var i = 0; i < candidates.length; i++) {\n    var char = candidates.charAt(i);\n    if (this.takenFlags.indexOf(char) === -1) {\n      this.takenFlags.push(char);\n      return char;\n    }\n  }\n};\n\n// generate service-daemons from\n// service.json\nCliBase.prototype.generate = function() {\n  var _this = this,\n    config = require('./config')();\n\n  this.logger.log('generating service wrappers:');\n\n  // generate OS-specific daemon wrappers, this process\n  // can be asynchrnous.\n  async.each(this.service.allServices(config.filter), function(service, done) {\n    service.generateScript(function(err) {\n      _this.logger.warn(\"  generated \" + service.scriptPath());\n      _this.logger.warn('  log path: ' + service.logFile);\n      done();\n    });\n  }, function() {\n    _this.service.printRunMessage();\n  });\n};\n\n// remove service-daemons\nCliBase.prototype.remove = function(serviceName) {\n  var _this = this;\n\n  // stop services before removing their wrappers.\n  this.stop(serviceName, function() {\n    // now remove the wrapper for each service.\n    _this.service.allServices(serviceName).forEach(function(service) {\n      service.removeScript(function() {\n        _this.logger.warn(\"  removed \" + service.scriptPath());\n      });\n    });\n  });\n};\n\n// start|stop|restart services.\nCliBase.prototype.start = function(serviceName, cb) {\n  this.logger.log('starting services:');\n  this._runCommand('start', serviceName, cb);\n};\n\nCliBase.prototype.stop = function(serviceName, cb) {\n  this.logger.log('stopping services:');\n  this._runCommand('stop', serviceName, cb);\n};\n\nCliBase.prototype.restart = function(serviceName, cb) {\n  this.logger.log('restarting services');\n  this._runCommand('restart', serviceName, cb);\n};\n\nCliBase.prototype._runCommand = function(command, serviceName, cb) {\n  var _this = this;\n\n  async.each(this.service.allServices(serviceName), function(service, done) {\n    service.runCommand(command, function(err) {\n      _this.logger.warn(\"  \" + command + \" \" + service.scriptPath());\n      done();\n    });\n  }, cb);\n};\n\n// Ask a user questions about the service they're\n// installing, and install it.\nCliBase.prototype.install = function(serviceName) {\n  var _this = this,\n    tmpServiceJsonPath = temp.path({suffix: '.json'}),\n    srcServiceJsonPath = Service._serviceJsonPath(serviceName),\n    interview = new this.Interview({\n      serviceJsonPath: srcServiceJsonPath,\n      tmpServiceJsonPath: tmpServiceJsonPath\n    });\n\n  interview.run(function() {\n    config.tmpServiceJsonPath = tmpServiceJsonPath; // point to temporary config.\n    _this.generate(serviceName); // generate the service wrappers.\n    _this.rimraf.sync(tmpServiceJsonPath); // remove the temporary service.json.\n  });\n};\n\n// list all available scripts.\nCliBase.prototype['list-scripts'] = function(serviceName) {\n  var _this = this;\n\n  this.service.allServices(serviceName).forEach(function(service) {\n    _this.logger.log(service.name + ':\\t' + service.description);\n    service.listScripts();\n  });\n};\n\n// run a script from package.json's scripts block, in the\n// context of service.json's args and envs.\nCliBase.prototype['run-script'] = function(scriptName) {\n  var _this = this,\n    filter = config.filter,\n    scriptsExecuted = 0;\n\n  scriptsExecuted = _.filter(this.service.allServices(filter), function(service) {\n    if (!service.hasScript(scriptName)) return false;\n\n    service.runScript(scriptName, function(err) {\n      if (err) _this.logger.error(err);\n    });\n\n    return true;\n  }).length;\n\n  if (!scriptsExecuted) this['list-scripts']();\n};\n\nexports.CliBase = CliBase;\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/config.js":"var _ = require('lodash'),\n  S = require('string'),\n  path = require('path'),\n  config = null,\n  fs = require('fs'),\n  rc = require('rc');\n\n// handles loading and detecting configuration\n// pulling together OS-specific variables,\n// ENV, and args.\nfunction Config(opts) {\n  _.extend(this, {\n    appName: 'ndm', // used by rc.\n    serviceJsonPath: path.resolve(process.cwd(), 'service.json'),\n    tmpServiceJsonPath: null, // used during install phase.\n    logsDirectory: this.defaultLogsDirectory(),\n    env: process.env,\n    uid: null,\n    gid: null,\n    console: null, // In upstart 1.4, where should logs be sent? <logged|output|owner|none>\n    sudo: null,\n    headless: false,\n    filter: null,\n    modulePrefix: '',\n    nodeBin: process.execPath,\n    baseWorkingDirectory: path.resolve(process.cwd()),\n    globalPackage: false,\n    platform: null, // override the platform ndm generates services for\n    platformApis: {\n      ubuntu: require('./platform-apis/ubuntu'),\n      centos: require('./platform-apis/centos'),\n      darwin: require('./platform-apis/darwin'),\n      initd: require('./platform-apis/init-d')\n    },\n    parsers: {\n      sudo: function(v) { return v.toString() === 'true' },\n      headless: function(v) { return v.toString() === 'true' },\n      globalPackage: function(v) { return v.toString() === 'true' }\n    }\n  }, opts);\n\n  // allow platform to be overridden.\n  this.platform = this.os();\n\n  // allow platform and env to be overridden before applying.\n  _.extend(this, this._getEnv(), opts);\n\n  this._rcOverride();\n};\n\n// called after loading configuration to update\n// config class with defaults for the\n// os-specific service being generated.\nConfig.prototype.updateWithOSDefaults = function() {\n  var _this = this,\n    osDefaults = this._getOSDefaults();\n\n  Object.keys(osDefaults).forEach(function(key) {\n    if (!_this._argv || !_this._argv[key]) _this[key] = osDefaults[key];\n  });\n}\n\n// override with settings in .ndmrc.\nConfig.prototype._rcOverride = function() {\n  var ndmrc = rc(this.appName, {}),\n    _this = this;\n\n  Object.keys(ndmrc).forEach(function(key) {\n    if (typeof _this[key] !== 'function') {\n      _this[key] = _this.parsers[key] ? _this.parsers[key](ndmrc[key]) : ndmrc[key];\n    }\n  });\n};\n\n// return the default log directory.\nConfig.prototype.defaultLogsDirectory = function() {\n  return path.resolve(process.cwd(), './logs')\n};\n\n// os specific config variables.\nConfig.prototype._getOSDefaults = function() {\n  // default to Ubuntu OS settings.\n  return (this.platformApis[this.platform] || this.platformApis['ubuntu']).configOverrides;\n};\n\n// return a set of descriptions for the various\n// command-line options. Any commands with descriptions\n// will automatically become available to the CLI.\nConfig.prototype.descriptions = function() {\n  return {\n    serviceJsonPath: 'path to service.json file',\n    sudo: 'should start|stop|restart command be run as super user?',\n    baseWorkingDirectory: 'where should ndm look for services?',\n    logsDirectory: 'where should service logs be generated?',\n    daemonsDirectory: 'where should the generated service daemons be stored?',\n    nodeBin: 'where does the node executable reside?',\n    uid: 'what user should scripts be executed as?',\n    gid: 'what group should scripts be executed as?',\n    console: 'set what to do with process console (see Upstart docs).',\n    platform: 'what OS platform is ndm being run on?',\n    filter: 'only execute run-script on the service name provided',\n    modulePrefix: 'npm prefix used to locate globally installed npm packages'\n  }\n};\n\n// environment variables of the form NDM_.\nConfig.prototype._getEnv = function() {\n  var _this = this,\n    opts = {};\n\n  Object.keys(this.env).forEach(function(key) {\n    if (key.match(/^NDM_/)) {\n      opts[S(key.replace(/^NDM_/, '').toLowerCase()).camelize().s] = _this.env[key];\n    }\n  });\n\n  return opts;\n};\n\n// detect the os that ndm is being run on.\nConfig.prototype.os = function() {\n  var _this = this;\n\n  if (this.platform) return this.platform;\n  else {\n    Object.keys(this.platformApis).forEach(function(key) {\n      var api = new _this.platformApis[key]();\n      if (api.isPlatform()) _this.platform = api.platform;\n    });\n\n    if (this.platform) return this.platform;\n  }\n\n  return process.platform;\n};\n\n// singleton pattern for grabbing config model.\nmodule.exports = function(opts, resetConfig) {\n  if (!config || resetConfig) config = new Config(opts);\n  else if (opts) _.extend(config, opts);\n\n  return config;\n};\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/platform-apis/ubuntu.js":"// API for Ubuntu Upstart 1.4.0.\nvar _ = require('lodash'),\n  path = require('path'),\n  PlatformBase = require('./platform-base').PlatformBase,\n  util = require('util');\n\nfunction Ubuntu(opts) {\n  _.extend(this, {\n    platform: 'ubuntu',\n    template: path.resolve(__dirname, '../../templates/upstart-ubuntu.ejs')\n  }, opts);\n}\n\nutil.inherits(Ubuntu, PlatformBase);\n\n// override default config variables.\nUbuntu.configOverrides = {\n  osLogsDirectory: '/var/log',\n  daemonsDirectory: '/etc/init',\n  sudo: true,\n  uid: 'ubuntu',\n  gid: 'ubuntu',\n  daemonExtension: '.conf'\n}\n\nUbuntu.prototype.start = function(service, cb) {\n  service.execCommand('service ' + service.name + ' start', cb);\n};\n\nUbuntu.prototype.stop = function(service, cb) {\n  service.execCommand('service ' + service.name + ' stop', cb);\n};\n\nUbuntu.prototype.restart = function(service, cb) {\n  service.execCommand('service ' + service.name + ' restart', cb);\n};\n\nmodule.exports = Ubuntu;\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/platform-apis/platform-base.js":"var _ = require('lodash'),\n  ejs = require('ejs'),\n  fs = require('fs'),\n  rimraf = require('rimraf'),\n  xmlescape = require('xml-escape');\n\n// An API for executing OS-specific commands,\n// and generating OS-specific daemon scripts.\nfunction PlatformBase(opts) {\n  _.extend(this, {\n    platform: null,\n    // path to template to use for service generation,\n    // use of a template may be optional.\n    template: null,\n    logger: require('../logger')\n  }, opts);\n}\n\n// Return any OS specific configuration overrides, e.g.,\n// where are logs traditionally placed on the given OS.\nPlatformBase.configOverrides = {};\n\n// return true if we detect that ndm is being run\n// on this platform. e.g., isPlatform would return true\n// on Centos if we find a releaseInfoFile with CentOS in it.\nPlatformBase.prototype.isPlatform = function() { return false; };\n\n// Given an abstract service, and CLI arguments, generate\n// service wrappers, e.g., upstart .conf files, and place\n// them in the appropriate location on the OS.\nPlatformBase.prototype.generateServiceScript = function(service, args, cb) {\n  // some special fields can be set in service.json\n  // to set nodeFlags on a process.\n  var nodeFlags = [];\n\n  try {\n    if (service.maxOldSpaceSize) nodeFlags.push('--max-old-space-size=' + service.maxOldSpaceSize)\n\n    fs.writeFileSync(\n      service.scriptPath(),\n      ejs.render(fs.readFileSync(this.template).toString(), _.merge({}, service, {\n        startScript: service._startScript(args),\n        flatArgs: args,\n        nodeFlags: nodeFlags,\n        xmlescape: function(s) {\n          if (typeof s === 'string') return xmlescape(s);\n          else return s;\n        }\n      })),\n      {\n        mode: 0755\n      }\n    );\n    return cb();\n  } catch (err) {\n    return cb(err); // we probably didn't have write permission.\n  }\n};\n\n// Remove the OS-specific script generated with ndm.\nPlatformBase.prototype.removeScript = function(service, cb) {\n  if (service.runnable()) rimraf.sync(service.scriptPath());\n  return cb();\n};\n\n// OS-specific command for starting a service, e.g.,\n// sudo service my-service start, for upstart.\nPlatformBase.prototype.start = function(service, cb) {\n  cb(Error('must implement start()'));\n};\n\n// OS-specific command for stopping abstract service.\nPlatformBase.prototype.stop = function(service, cb) {\n  cb(Error('must implement stop()'));\n};\n\n// OS-specific command for restarting abstract service.\nPlatformBase.prototype.restart = function(service, cb) {\n  var _this = this;\n\n  this.stop(service, function(error) {\n    if(error) _this.logger.error(error.message);\n    _this.start(service, cb);\n  });\n};\n\nexports.PlatformBase = PlatformBase;\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/platform-apis/centos.js":"// API for Centos Upstart 0.6.\nvar _ = require('lodash'),\n  fs = require('fs'),\n  path = require('path'),\n  PlatformBase = require('./platform-base').PlatformBase,\n  util = require('util');\n\nfunction Centos(opts) {\n  _.extend(this, {\n    platform: 'centos',\n    releaseInfoFile: '/etc/redhat-release',\n    template: path.resolve(__dirname, '../../templates/upstart-centos.ejs')\n  }, opts);\n}\n\nutil.inherits(Centos, PlatformBase);\n\n// override default config variables.\nCentos.configOverrides = {\n  osLogsDirectory: '/var/log',\n  daemonsDirectory: '/etc/init',\n  daemonExtension: '.conf',\n  sudo: false\n}\n\n// Use /etc/redhat-release to determine if platform is Centos.\nCentos.prototype.isPlatform = function() {\n  if (!fs.existsSync(this.releaseInfoFile)) return false;\n  else return !!fs.readFileSync(this.releaseInfoFile, 'utf-8').match(/CentOS/);\n};\n\nCentos.prototype.start = function(service, cb) {\n  service.execCommand('initctl start ' + service.name, cb);\n};\n\nCentos.prototype.stop = function(service, cb) {\n  service.execCommand('initctl stop ' + service.name, cb);\n};\n\nCentos.prototype.restart = function(service, cb) {\n  service.execCommand('initctl restart ' + service.name, cb);\n};\n\nmodule.exports = Centos;\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/platform-apis/darwin.js":"// API for OSX launchctl.\nvar _ = require('lodash'),\n  path = require('path'),\n  PlatformBase = require('./platform-base').PlatformBase,\n  util = require('util');\n\nfunction Darwin(opts) {\n  _.extend(this, {\n    platform: 'darwin',\n    template: path.resolve(__dirname, '../../templates/launchctl.ejs')\n  }, opts);\n}\n\nutil.inherits(Darwin, PlatformBase);\n\n// override default config variables.\nDarwin.configOverrides = {\n  osLogsDirectory: process.env['HOME'] ? path.resolve(process.env['HOME'], './Library/Logs/') : '~/',\n  daemonsDirectory: '~/Library/LaunchAgents/',\n  daemonExtension: '.plist'\n}\n\nDarwin.prototype.start = function(service, cb) {\n  service.execCommand('launchctl load ' + service.scriptPath(), cb);\n};\n\nDarwin.prototype.stop = function(service, cb) {\n  service.execCommand('launchctl unload ' + service.scriptPath(), cb);\n};\n\nDarwin.prototype.restart = function(service, cb) {\n  service.execCommand('launchctl unload ' + service.scriptPath() + ';launchctl load ' + service.scriptPath(), cb);\n};\n\nmodule.exports = Darwin;\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/platform-apis/init-d.js":"// API for init-d scripts.\nvar _ = require('lodash'),\n  fs = require('fs'),\n  path = require('path'),\n  PlatformBase = require('./platform-base').PlatformBase,\n  util = require('util');\n\nfunction InitD(opts) {\n  _.extend(this, {\n    platform: 'initd',\n    template: path.resolve(__dirname, '../../templates/init-d.ejs')\n  }, opts);\n}\n\nutil.inherits(InitD, PlatformBase);\n\n// override default config variables.\nInitD.configOverrides = {\n  osLogsDirectory: '/var/log',\n  daemonsDirectory: '/etc/init.d',\n  daemonExtension: '',\n  sudo: true,\n  uid: 'root'\n}\n\nInitD.prototype.start = function(service, cb) {\n  service.execCommand('service ' + service.name + ' start', cb);\n};\n\nInitD.prototype.stop = function(service, cb) {\n  service.execCommand('service ' + service.name + ' stop', cb);\n};\n\nInitD.prototype.restart = function(service, cb) {\n  service.execCommand('service ' + service.name + ' restart', cb);\n};\n\nmodule.exports = InitD;\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/service.js":"var _ = require('lodash'),\n  fs = require('fs'),\n  ejs = require('ejs'),\n  path = require('path'),\n  rimraf = require('rimraf');\n\n// an OS-specific service wrapper for\n// a Node.js process.\nfunction Service(opts) {\n  _.extend(this,\n    {\n      description: '',\n      utils: require('./utils'),\n      logger: require('./logger')\n    },\n    require('./config')(),\n    opts\n  );\n\n  // scoped modules contain a '/' (@foo/bar).\n  // this causes problems when generating logs/scripts\n  // on some platforms.\n  this.name = this.name.replace('/', '_');\n\n  // run the script within its ndm\n  // node_modules directory.\n  this.workingDirectory = this._workingDirectory();\n\n  this.logFile = this.utils.resolve(\n    this.logsDirectory,\n    this.name + '.log'\n  );\n\n  this._copyFieldsFromPackageJson(); // try to grab some sane defaults from package.json.\n};\n\n// Determine working directory, if the module itself\n// is referenced in service.json, this may be ./ otherwise\n// it will be ./node_modules/[module-name].\nService.prototype._workingDirectory = function() {\n  var packageJson = this.utils.loadServiceJson(path.resolve(\n      this.baseWorkingDirectory,\n      './package.json'\n    )),\n    module = this.module || this.name;\n\n  if (packageJson.name === module) {\n    return this.utils.resolve(this.baseWorkingDirectory);\n  } else {\n    return this.utils.resolve(\n      this.baseWorkingDirectory,\n      './node_modules',\n      this.module\n    )\n  }\n};\n\n// get an instance of the platform-api, based\n// on the current configuration settings.\nService.prototype._getPlatformApi = function() {\n  var API = this.platformApis[this.platform] || this.platformApis['ubuntu'];\n  return new API();\n};\n\n// Generate a daemon wrapper from an ejs template.\nService.prototype.generateScript = function(cb) {\n  var _this = this;\n\n  if (this.runnable()) {\n    // create copy of args, so that we can\n    // non-destructively update with args from scipts.start.\n    var flatArgs = _.isArray(this.args) ? this.args : this._flattenArgs();\n\n    // add all arguments after -- to generated\n    // script as run arguments.\n    if (process.argv.indexOf('--') !== -1) {\n      process.argv.slice(\n        process.argv.indexOf('--') + 1\n      ).forEach(function(arg) {\n        Array.prototype.push.apply(flatArgs, arg.split('='));\n      });\n    }\n\n    this._getPlatformApi().generateServiceScript(this, flatArgs, function(err) {\n      if (err) _this.logger.error(err.message);\n      return cb();\n    });\n  } else {\n    this.logger.warn('  ' + this.name + ' does not have start script.');\n    return cb();\n  }\n};\n\n// Remove the generated daemon wrapper\nService.prototype.removeScript = function(cb) {\n  this._getPlatformApi().removeScript(this, function() {\n    return cb();\n  });\n};\n\n// convert args hash to arg list.\nService.prototype._flattenArgs = function() {\n  var _this = this,\n    flatArgs = [];\n\n  Object.keys(this.args).forEach(function(key) {\n    flatArgs.push(key);\n    flatArgs.push(_this.args[key]);\n  });\n\n  return flatArgs;\n};\n\n// replace scripts.start with a standardized\n// bin that executes on more platforms.\nService.prototype._startScript = function(runArgs) {\n  var startScript = this.scripts.start.replace(/^node +/, ''),\n    splitScript = startScript.split(/[ =]/);\n\n  startScript = splitScript.shift();\n  runArgs.unshift.apply(runArgs, splitScript);\n\n  return startScript;\n};\n\n// is this service runnable? it could just\n// provide CLI functionality.\nService.prototype.runnable = function() {\n  return this.scripts && this.scripts.start;\n};\n\n// where should we save the system daemon to?\n// /etc/init.d, ~/Library/LaunchAgents.\nService.prototype.scriptPath = function() {\n  return this.utils.resolve(\n    this.daemonsDirectory,\n    this.name + this.daemonExtension\n  );\n};\n\n// actually exec a command, optionally as a super user.\nService.prototype.runCommand = function(command, cb) {\n  this._getPlatformApi()[command](this, cb);\n};\n\n// Helper for executing commands in child processes.\n// actually exec a command, optionally as a super user.\nService.prototype.execCommand = function(command, cb) {\n  if (this.runnable()) {\n    this.utils.exec(\n      (this.sudo ? 'sudo ' : '') + command,\n      cb\n    );\n  }\n};\n\n// Does the service have a script corresponding\n// to the name provided.\nService.prototype.hasScript = function(script) {\n  return Object.keys(this.scripts).indexOf(script) > -1;\n};\n\n// run a script in the context of environment and argument\n// variables described in service.json.\nService.prototype.runScript = function(script, cb) {\n  var _this = this,\n    cmd = \"\";\n\n  if (!this.hasScript(script)) return cb();\n\n  // prepend environment variables to command.\n  Object.keys(this.env).forEach(function(k) {\n    cmd += k + '=\"' + _this.env[k] + '\" ';\n  });\n\n  cmd += this.scripts[script];\n\n  // append arguments to command.\n  Object.keys(this.args).forEach(function(k) {\n    cmd += \" \" + k + \" \" + _this._fixPath(_this.args[k]);\n  });\n\n  // execute with every argument after run-script <script>.\n  process.argv.slice(\n    process.argv.indexOf('run-script') + 2\n  ).forEach(function(arg) {\n    cmd += \" \" + _this._fixPath(arg);\n  });\n\n  this.utils.exec(cmd, this.workingDirectory, cb);\n};\n\n// replace characters such as ./ and ~/ with the\n// appropriate expansion of the path.\nService.prototype._fixPath = function(arg) {\n  arg = arg.replace(/^~\\//, process.env['HOME'] + '/');\n  arg = arg.replace(/=~\\//, '=' + process.env['HOME'] + '/');\n\n  arg = arg.replace(/^.\\//, path.resolve('./') + '/');\n  arg = arg.replace(/=.\\//, '=' + path.resolve('./') + '/');\n  return arg;\n};\n\nService.prototype.listScripts = function() {\n  var _this = this,\n    msg = \"\";\n\n  Object.keys(this.scripts).forEach(function(name) {\n    msg += \"  \" + name + \"\\n\";\n  });\n\n  this.logger.success(msg.replace(/\\n$/, ''));\n};\n\n// if the service.json has a corresponding package.json\n// in script.baseWorkingDirectory, copy any missing fields\n// over from the package.json to the service.json.\nService.prototype._copyFieldsFromPackageJson = function() {\n  var _this = this,\n    fieldsToCopy = ['scripts', 'description'],\n    packageJson = null,\n    packageJsonPath = path.resolve(path.dirname(this.serviceJsonPath), 'package.json');\n\n  // there is no package.json in the working directory!\n  if (!fs.existsSync(packageJsonPath)) return;\n\n  packageJson = this.utils.loadServiceJson(packageJsonPath);\n\n  // we shouldn't copy fields from package.json unless\n  // name and this.module match up.\n  if (packageJson.name !== this.module) return;\n\n  fieldsToCopy.forEach(function(field) {\n    if (!_this[field] && packageJson[field]) _this[field] = packageJson[field];\n  });\n};\n\nexports.printRunMessage = function() {\n  var logger = require('./logger');\n\n  logger.log(\"\\nto start all services run: '\" + require('./config')().appName + \" start'\");\n  logger.log(\"or manually start the service using 'launchctl', 'initctl', or 'upstart'\");\n  logger.success(\"\\nsuccess!\");\n};\n\n// load and return all services.\nexports.allServices = function(serviceNameFilter) {\n  var config = require('./config')(),\n    serviceJson = null,\n    serviceJsonPath = exports._serviceJsonPath(serviceNameFilter),\n    utils = require('./utils');\n\n  // raise a human readable error if we can't find\n  // the service.json file.\n  try {\n    serviceJson = fs.readFileSync(\n      config.tmpServiceJsonPath ? config.tmpServiceJsonPath : utils.resolve(serviceJsonPath)\n    ).toString();\n  } catch (e) {\n    throw Error('could not load ' + serviceJsonPath + ' run ndm init, to create a service.json from your package.json.')\n  }\n\n  try {\n    serviceJson = JSON.parse(serviceJson);\n  } catch (e) {\n    throw Error('invalid service.json, check file for errors.');\n  }\n\n  if (!config.tmpServiceJsonPath && serviceJsonPath.indexOf('package.json') !== -1) {\n    // we are attempting to load a package.json rather than a service.json.\n    return parseServiceJson(\n      serviceNameFilter,\n      exports.transformPackageJson(serviceJson)\n    );\n  } else {\n    // serviceJsonPath points to a service.json file.\n    return parseServiceJson(serviceNameFilter, serviceJson);\n  }\n};\n\n// convert a package.json into a service.json format and parse it.\nexports.transformPackageJson = function(packageJson) {\n  var serviceJson = {},\n    innerJson = serviceJson[packageJson.name] = {};\n\n  // map fields from the format expected in package.json, to the format\n  // used by service.json.\n  if (packageJson.description) innerJson.description = packageJson.description;\n  if (packageJson.scripts) innerJson.scripts = packageJson.scripts;\n  if (packageJson.service) { // special fields specific to ndm.\n    if (packageJson.service.args) innerJson.args = packageJson.service.args;\n    if (packageJson.service.env) innerJson.env = packageJson.service.env;\n  }\n\n  return serviceJson;\n}\n\n// service.json files can be used to describe multiple\n// services, they have a slightly different format than\n// package.json.\nfunction parseServiceJson(serviceNameFilter, serviceJson) {\n  var services = [],\n    config = require('./config')();\n\n  Object.keys(serviceJson).forEach(function(serviceName) {\n    if (serviceName === 'env' || serviceName === 'args') return;\n\n    var serviceConfig = serviceJson[serviceName],\n      processCount = serviceConfig.processes || 1;\n\n    // if services have a process count > 1,\n    // we'll create multiple run-scripts for them.\n    _.range(processCount).forEach(function(i) {\n\n      // apply sane defaults as we create\n      // the services.\n      var service = new Service(_.extend(\n        {\n          module: serviceName,\n          name: i > 0 ? (serviceName + '-' + i) : serviceName\n        },\n        serviceConfig\n      ));\n\n      // override env and args with global args and env.\n      service.env = _.extend({},\n        dropInterviewQuestions(serviceJson.env),\n        dropInterviewQuestions(serviceConfig.env)\n      );\n\n      service.args = serviceConfig.args;\n\n      if (_.isArray(serviceConfig.args)) {\n        // combine arrays of arguments, if both top-level args.\n        // and service-level args are an array.\n        if (_.isArray(serviceJson.args)) service.args = [].concat(serviceJson.args, service.args);\n      } else {\n        // merge objects together if top-level, and service level\n        // arguments are maps.\n        service.args = _.extend({},\n          dropInterviewQuestions(serviceJson.args),\n          dropInterviewQuestions(serviceConfig.args)\n        );\n      }\n\n      // we can optionaly filter to a specific service name.\n      if (serviceNameFilter && service.name !== serviceNameFilter && !config.globalPackage) return;\n\n      // replace placeholder variables\n      // in the service.json.\n      expandVariables(service, i);\n\n      services.push(service);\n    });\n  });\n\n  return services;\n}\n\n// convert defaults of form \"argument\": {\"default\": \"33\", description: \"my arg\"}.\n// to values that can be used when generating services.\nfunction dropInterviewQuestions(o) {\n  return _.reduce(o, function(result, v, k) {\n    var value = typeof v === 'object' ? v.default : v;\n    return (result[k] = value, result)\n  }, {});\n}\n\n// the %i placeholder can be used to reference the process\n// number in args/env variables within service.json.\nfunction expandVariables(service, processNumber) {\n  // first the simple case of env, which is always an object.\n  service.env = _.reduce(service.env, function(result, v, k) {\n    var value = typeof v === 'string' ? v.replace(/%i/g, processNumber) : v;\n    return (result[k] = value, result)\n  }, {});\n\n  // next, the more annoying usecase of args which can be\n  // an array on an object.\n  if (_.isArray(service.args)) {\n    service.args = _.map(service.args, function(arg) {\n      return typeof arg === 'string' ? arg.replace(/%i/g, processNumber) : arg;\n    });\n  } else {\n    service.args = _.reduce(service.args, function(result, v, k) {\n      var value = typeof v === 'string' ? v.replace(/%i/g, processNumber) : v;\n      return (result[k] = value, result)\n    }, {});\n  }\n};\n\n// look for a service manifest in cascade of logical places.\nexports._serviceJsonPath = function(serviceNameFilter) {\n  var config = require('./config')(),\n    packageJsonPath = path.resolve(path.dirname(config.serviceJsonPath), './package.json'),\n    baseWorkingDirectory = null,\n    pathsToCheck = [\n      path.resolve(config.modulePrefix, 'node_modules'),\n      path.resolve(config.modulePrefix, 'lib', 'node_modules'),\n      './node_modules',\n      config.baseWorkingDirectory\n    ];\n\n  if (fs.existsSync(config.serviceJsonPath)) return config.serviceJsonPath;\n  else if (fs.existsSync(packageJsonPath)) {\n    // did we find a package.json, and does it have the same\n    // 'name' as serviceNameFilter?\n    try {\n      var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));\n      if (!serviceNameFilter || packageJson.name === serviceNameFilter) return packageJsonPath;\n    } catch (e) {\n      throw Error('could not load ' + packageJsonPath + '.')\n    }\n  } else if (!serviceNameFilter) return config.serviceJsonPath;\n\n  var baseWorkingDirectory = _.filter(pathsToCheck, function(serviceJsonPath) {\n    return fs.existsSync(\n      path.resolve(serviceJsonPath, serviceNameFilter)\n    );\n  })[0];\n\n  // we found a good candidate for a\n  // working directory, update config appropriately.\n  if (baseWorkingDirectory) {\n    baseWorkingDirectory = path.resolve(baseWorkingDirectory, serviceNameFilter);\n    config.baseWorkingDirectory = baseWorkingDirectory;\n\n    var serviceJsonPath = path.resolve(baseWorkingDirectory, 'service.json'),\n      packageJsonPath = path.resolve(baseWorkingDirectory, 'package.json');\n\n    // look for a service.json, fall back to the package.json.\n    if (fs.existsSync(serviceJsonPath)) config.serviceJsonPath = serviceJsonPath;\n    else config.serviceJsonPath = packageJsonPath;\n\n    // only use global logs directory if we're not overriding the logs dir.\n    if (config.logsDirectory === config.defaultLogsDirectory()) {\n      config.logsDirectory = config.osLogsDirectory;\n    }\n\n    //use global interpretation of commands: ndm <cmd> <global-package>\n    config.globalPackage = true;\n  };\n\n  return config.serviceJsonPath;\n};\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/installer.js":"var _ = require('lodash'),\n  fs = require('fs'),\n  mkdirp = require('mkdirp'),\n  logger = require('./logger'),\n  utils = require('./utils');\n\n// install ndm service.json, and initialize\n// the ndm directory based on package.json.\nfunction Installer(opts) {\n  _.extend(this,\n    {},\n    require('./config')(),\n    opts\n  );\n}\n\n// create the service.json from the package.json.\nInstaller.prototype.init = function() {\n  var logDirectory = utils.resolve(this.baseWorkingDirectory, 'logs');\n\n  this._generateServiceJson();\n  mkdirp.sync(logDirectory);\n\n  logger.warn(\"  created \" + logDirectory);\n  this._printInitMessage();\n};\n\n// this method handles both the update and generation use-case.\nInstaller.prototype._generateServiceJson = function(update) {\n  var _this = this,\n    packageJson = this._getPackageJson(this.baseWorkingDirectory),\n    servicesJson = {};\n\n  if (update && !(fs.existsSync(this.serviceJsonPath))) {\n    throw Error(serviceJsonPath + ' does not exist. run ndm init.')\n  } else if (update) {\n    servicesJson = utils.loadServiceJson(this.serviceJsonPath);\n  } else if (fs.existsSync(this.serviceJsonPath)) {\n    throw Error(_this.serviceJsonPath + ' already exists.');\n  }\n\n  if (!packageJson.dependencies) throw Error('no services found, add dependencies to package.json.');\n\n  // walk all the dependencies in package.json, and copy\n  // env, args, and scripts into default serviceJson.\n  Object.keys(packageJson.dependencies).forEach(function(module) {\n    var moduleDirectory = utils.resolve(\n        _this.baseWorkingDirectory,\n        'node_modules',\n        module\n      ),\n      moduleName = module.replace(/^@.*\\//, ''),\n      serviceJson = null,\n      moduleJson = null;\n\n    moduleJson = _this._getPackageJson(moduleDirectory);\n    serviceJson = moduleJson.service || {};\n\n    if (!servicesJson[moduleName]) {\n      servicesJson[moduleName] = {\n        description: moduleJson.description,\n        scripts:  _.merge({}, moduleJson.bin, moduleJson.scripts),\n        env: serviceJson.env || {},\n        args: serviceJson.args || {},\n      }\n\n      // scoped packages should have a module stanza which\n      // points to the appropriate folder.\n      if (moduleName !== module) servicesJson[moduleName].module = module;\n    }\n  });\n\n  fs.writeFileSync(this.serviceJsonPath, JSON.stringify(servicesJson, null, '  '));\n  logger.warn(\"  generated \" + this.serviceJsonPath);\n};\n\n// update service.json with new entries in package.json.\nInstaller.prototype.update = function() {\n  this._generateServiceJson(true);\n  this._printInitMessage();\n};\n\nInstaller.prototype._getPackageJson = function(basePath) {\n  var packagePath = utils.resolve(\n    basePath,\n    'package.json'\n  );\n\n  if (!fs.existsSync(packagePath)) throw Error(packagePath + \" did not exist.\\nadd your dependencies to package.json, and run npm install.\")\n\n  return JSON.parse(\n    fs.readFileSync(packagePath).toString()\n  );\n};\n\n// tell the user how to start services after they run init.\nInstaller.prototype._printInitMessage = function() {\n  logger.log(\"\\nedit aservice.json' to setup your application's environment.\");\n  logger.log(\"when you're ready, run 'ndm generate' to generate service wrappers.\");\n  logger.log(\"add dependencies to 'package.json' and run 'ndm update' to add additional services.\");\n  logger.success(\"\\nsuccess!\");\n};\n\nmodule.exports = Installer;\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/logger.js":"var chalk = require('chalk'),\n  config = require('./config')(),\n  errorLogged = false;\n\nexports.log = function(message) {\n  if (!config.headless) {\n    console.log(message);\n  }\n};\n\nexports.warn = function(message) {\n  this.log(chalk.yellow(message));\n};\n\nexports.error = function(message) {\n  errorLogged = true;\n  this.log(chalk.red(message));\n};\n\nexports.success = function(message) {\n  this.log(chalk.green(message));\n};\n\nexports.errorLogged = function() {\n  return errorLogged;\n};\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/utils.js":"// common utilities, e.g., loading and parsing JSON.\nvar logger = require('./logger'),\n  fs = require('fs'),\n  spawn = require('child_process').spawn,\n  path = require('path');\n\n// load and parse the service JSON.\nexports.loadServiceJson = function(path) {\n  var services = null;\n\n  try {\n    services = fs.readFileSync(path).toString();\n  } catch (e) {\n    throw Error('could not load ' + path);\n  }\n\n  try {\n    services = JSON.parse(services);\n  } catch (e) {\n    throw Error('invalid json in ' + path + ', check file for errors.');\n  }\n\n  return services;\n};\n\n// write service.json back to disk.\nexports.writeServiceJson = function(path, services) {\n  try {\n    fs.writeFileSync(path, JSON.stringify(services, null, '  '));\n    logger.success('wrote ' + path + ' to disk.')\n  } catch (e) {\n    throw Error('failed to write to ' + path);\n  }\n};\n\n// actually exec a command, optionally as a super user.\nexports.exec = function(command, cwd, cb) {\n  // working directory is optional.\n  if (typeof cwd === 'function') {\n    cb = cwd;\n    cwd = './';\n  }\n\n  var proc = spawn('sh', ['-c', command], {\n    cwd: cwd,\n    env: process.env,\n    stdio: [process.stdin, process.stdout, null]\n  });\n\n  proc.stderr.on('data', function(data) {\n    logger.error('  ' + data.toString().trim());\n  });\n\n  proc.on('close', function(output) {\n    cb();\n  });\n};\n\n// resolve path, handling ~/ argument.\nexports.resolve = function() { // (...)\n  var args = Array.prototype.slice.call(arguments);\n\n  // replace ~/ with absolute path.\n  args[0] = args[0].replace('~/', process.env['HOME'] + '/');\n\n  return path.resolve.apply(this, args);\n};\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/interview.js":"var _ = require('lodash'),\n  Service = require('./service'),\n  utils = require('./utils'),\n  uuid = require('node-uuid');\n\n// ask the user to fill in any variables in\n// the service.json of the form <description of value>.\nfunction Interview(opts) {\n  _.extend(this,\n    {\n      inquirer: require('inquirer'),\n      questionLookup: {},\n      logger: require('./logger'),\n      services: null,\n      // optionally we can output service.json\n      // to a temporary file.\n      tmpServiceJsonPath: null\n    },\n    require('./config')(),\n    opts\n  );\n\n  this._loadServiceJson();\n}\n\n// load service.json handling special-case of\n// reading configuration from package.json.\nInterview.prototype._loadServiceJson = function() {\n  this.services = utils.loadServiceJson(this.serviceJsonPath);\n\n  // we appear to be loading a package.json.\n  if (this.serviceJsonPath.indexOf('package.json') !== -1) {\n\n    // convert package.json to service.json.\n    this.services = Service.transformPackageJson(this.services);\n  }\n};\n\n// run the interactive interview.\nInterview.prototype.run = function(cb) {\n  var _this = this;\n\n  // generate questions from service.json.\n  _this._generateQuestions();\n\n  var questions = this._inquirerQuestions();\n\n  this.inquirer.prompt(questions, function(answers) {\n    if (!answers || _this.tmpServiceJsonPath || answers.overwrite) {\n      _this._updateServiceVariables(answers);\n    } else {\n      _this.logger.error('aborted writing service.json')\n    }\n    cb();\n  });\n};\n\n// update the stored services object with\n// the answers to the interview.\nInterview.prototype._updateServiceVariables = function(answers) {\n  var _this = this;\n\n  Object.keys(answers).forEach(function(answerKey) {\n    var answer = answers[answerKey],\n      question = _this.questionLookup[answerKey];\n\n    if (question) question.parent[question.key] = answer;\n  });\n\n  utils.writeServiceJson(this.tmpServiceJsonPath || this.serviceJsonPath, this.services);\n};\n\n// generate questions in a form inquirer can use.\nInterview.prototype._inquirerQuestions = function() {\n  var _this = this,\n    questions = [];\n\n  Object.keys(this.questionLookup).forEach(function(name) {\n    var question = {\n      message: _this.questionLookup[name].message,\n      name: name\n    }\n\n    // default values are optional.\n    if (_this.questionLookup[name].default) question.default = _this.questionLookup[name].default;\n\n    questions.push(question);\n  });\n\n  // confirm that the user actually wants to overwrite\n  // service.json.\n  if (!_this.tmpServiceJsonPath) {\n    questions.push({\n      name: 'overwrite',\n      type: 'confirm',\n      message: 'overwrite service.json with new values?'\n    });\n  }\n\n  return questions;\n};\n\n// Generate a mapping of questions, convenient for\n// prompting the user with inquirer, and for\n// modifying the origina JSON.\nInterview.prototype._generateQuestions = function() {\n  var _this = this;\n\n  // generate questions from the global args object.\n  Object.keys(this.services.args || {}).forEach(function(arg) {\n    _this._addQuestion('args:' + arg, _this.services.args);\n  });\n\n  // generate questions from the global env object.\n  Object.keys(this.services.env || {}).forEach(function(env) {\n    _this._addQuestion('env:' + env, _this.services.env);\n  });\n\n  // now generate interview questions for each service.\n  Object.keys(this.services).forEach(function(key) {\n    if (key === 'args' || key === 'env') return;\n\n    // add questions pulled from args.\n    Object.keys(_this.services[key].args || {}).forEach(function(arg) {\n      _this._addQuestion(key + ':args:' + arg, _this.services[key].args);\n    });\n\n    // add questions pulled from env.\n    Object.keys(_this.services[key].env || {}).forEach(function(env) {\n      _this._addQuestion(key + ':env:' + env, _this.services[key].env);\n    });\n  });\n};\n\n// check whether a question should be interviewed for\n// and add to questions array.\nInterview.prototype._addQuestion = function(uniqueKey, parent) {\n  var key = uniqueKey.split(':').pop(),\n    value = parent[key];\n\n  if (typeof value === 'object') {\n    // this key did not collide, we do not need\n    // to namespace it.\n    if (!this.questionLookup[key]) uniqueKey = key;\n\n    this.questionLookup[uniqueKey] = {\n      key: key, // key to modify in original JSON.\n      parent: parent, // node in original JSON to modify,\n      message: value.description, // description for inquirer.\n      default: (value.default || '').replace('{{uuid}}', uuid.v4()) // default value to display.\n    };\n  };\n};\n\nmodule.exports = Interview;\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/bin/ndm.js":"#!/usr/bin/env node\n\nrequire('../lib/cli')().run();\n\n// emit the appropriate exit code before shutting down.\nprocess.on('exit', function() {\n  if (require('../lib/logger').errorLogged()) process.exit(1);\n  else process.exit(0);\n});\n","/home/travis/build/npmtest/node-npmtest-ndm/node_modules/ndm/lib/cli.js":"// the CLI helper used by ndm itself.\nvar _ = require('lodash'),\n  async = require('async'),\n  cli = null,\n  CliBase = require('./cli-base').CliBase,\n  config = require('./config')(),\n  fs = require('fs'),\n  Installer = require('./installer'),\n  path = require('path'),\n  Service = require('./service'),\n  S = require('string'),\n  temp = require('temp'),\n  util = require('util'),\n  npmconf = require('npmconf');\n\n// handle a user interacting with the\n// command-line, update config appropriately,\n// output human readable messages.\nfunction Cli(opts) {\n  _.extend(this, {\n    logger: require('./logger'),\n    Interview: require('./interview'),\n    service: Service,\n    rimraf: require('rimraf'),\n    yargs: require('yargs'), // overridable parsed arguments.\n    takenFlags: [],\n    commands: {\n      'install': \"ask user about environment variables and install service.\",\n      'start': \"start all, or a specific service.\",\n      'stop': \"stop all, or a specific service.\",\n      'restart': \"restart all, or a specific service.\",\n      'remove': \"remove OS-specific daemon wrappers.\",\n      'init': \"create the ndm service.json.\",\n      'generate': \"generate OS-specific daemon wrappers.\",\n      'update': \"update service.json with new services.\",\n      'list': \"list all services availble in service.json\",\n      'interview': \"ask the user to fill in missing fields in service.json\",\n      'run-script': \"run script with env and args from service.json\",\n      'list-scripts': \"list all the scripts provided by ndm services\",\n      'version': \"print the current version of ndm that is installed\"\n    }\n  }, opts);\n};\n\nutil.inherits(Cli, CliBase);\n\n// actually run the cli, the cli is also\n// included and used for logging.\nCli.prototype.run = function() {\n  var _this = this,\n    argv = null;\n\n  this.generateArgs();\n\n  argv = this.yargs.argv;\n\n  if (argv._.length === 0 || argv.help) {\n    this.logger.log(this.yargs.help());\n  } else if (!this.commands[argv._[0]]){\n    this.logger.error('command ' + argv._[0] + ' not found')\n    this.logger.log(this.yargs.help());\n  } else {\n    // make the aliases actually work.\n    argv = this.yargs.normalize().argv;\n\n    npmconf.load(function (er, conf) {\n      // update config singleton.\n      _this.updateConfigWithNpmconf(conf);\n      _this.updateConfigWithArgs(argv);\n      config.updateWithOSDefaults();\n\n      try { // execute the command, passing along args.\n        _this[argv._[0]].apply(_this, argv._.slice(1));\n      } catch (e) {\n        _this.logger.error(e.message);\n      }\n    });\n  }\n};\n\n// initialize ndm directory.\nCli.prototype.init = function() {\n  this.logger.log(\"setting up ndm directory:\");\n  (new Installer()).init();\n};\n\n// update service.json with new\n// services in package.json.\nCli.prototype.update = function() {\n  this.logger.log(\"updating service.json:\");\n  (new Installer()).update();\n};\n\n// list all available services.\nCli.prototype.list = function(serviceName) {\n  var _this = this;\n\n  this.service.allServices(serviceName).forEach(function(service) {\n    _this.logger.log(service.name + \":\\t\" + service.description);\n  });\n};\n\n// interactive Q/A session with service.json.\nCli.prototype.interview = function() {\n  var interview = new this.Interview();\n  interview.run(function() {});\n};\n\n// prints the current version of ndm that is installed.\nCli.prototype.version = function() {\n  var packageJson = JSON.parse(fs.readFileSync(\n    path.resolve(__dirname, '../package.json'), 'utf-8'\n  ));\n\n  this.logger.success('ndm version ' + packageJson.version);\n  this.logger.warn('services in the cloud!');\n};\n\n// export CLI as a singleton, to that\n// it can easily be imported for logging.\nmodule.exports = function(opts) {\n  if (!opts && cli) return cli;\n  else {\n    cli = new Cli(opts);\n    return cli;\n  }\n};\n"}